#!/usr/bin/perl
# -*- coding: ascii -*-
#
# grake
# Copyright (C) 2010-2011  Toni Gundogdu <legatvs@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use warnings;
use strict;
use v5.10;

binmode STDOUT, ":utf8";
binmode STDERR, ":utf8";

use version 0.77 (); our $VERSION = version->declare("0.1.0");

use Getopt::ArgvFile(home => 1, startupFilename => [qw(.grakerc)]);
use Getopt::Long qw(:config bundling);
use Carp qw(croak);

my %config;

exit main();

sub help
{
  require Pod::Usage;
  Pod::Usage::pod2usage(-exitstatus => 0, -verbose => 1);
}

sub init
{
  GetOptions(
             \%config,
             'interactive|i',
             'title|t',
             'json',
             'csv',
             'proxy=s',
             'no_proxy|no-proxy',
             'quiet|q',
             'version' => \&version,
             'help'    => \&help,
            ) or exit 1;

  help if scalar @ARGV == 0;

  $config{title} ||= $config{json};
  $config{title} ||= $config{csv};
}

sub version
{
  eval "require Umph::Prompt";
  my $p = $@ ? "" : ", Umph::Prompt version $Umph::Prompt::VERSION";
  say "grake version $VERSION$p
Copyright (C) 2010-2011  Toni Gundogdu
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.";
  exit 0;
}

my @ids;
my @links;

sub spew_qe {print STDERR @_ unless $config{quiet}}

sub main
{
  init();

  spew_qe "Checking ...";

  require LWP;
  my $a = new LWP::UserAgent;
  $a->env_proxy;    # http://search.cpan.org/perldoc?LWP::UserAgent
  $a->proxy('http', $config{proxy}) if $config{proxy};
  $a->no_proxy('') if $config{no_proxy};

  # Match: /watch?v=, /v/, /embed/
  # (At least) Hulu uses the same "/embed/" which is why we no longer
  # use the "(?>[-_\w]{11})".

  my $q = qr{[?/](?:embed|v)[=/]((?>[-_\w]+))};
  my $n = 0;

  require URI::Escape;

  foreach (@ARGV)
  {
    my $r = $a->get($_);

    unless ($r->is_success)
    {
      printf STDERR "\nerror: $_: %s\n", $r->status_line;
      next;
    }

    my $d = URI::Escape::uri_unescape($r->content);
    @ids = weed(uniq2((@ids, $d =~ /$q/g)));

    spew_qe((++$n % 5 == 0) ? " " : ".");
  }

  if (scalar @ids == 0)
  {
    croak "error: nothing found\n";
  }
  else {spew_qe "done.\n"}

  spew_qe "Get video title ..." if $config{title};

  $n = 0;
  foreach my $id (@ids)
  {
    my %tmp = (
            id  => $id,
            url => "http://youtube.com/watch?v=$id",
            gvi => "http://www.youtube.com/get_video_info?&video_id=$id"
              . "&el=detailpage&ps=default&eurl=&gl=US&hl=en",
            title    => undef,
            selected => 1
    );

    $tmp{title} = get_title($a, \%tmp, $n) if $config{title};
    push @links, \%tmp;
    ++$n;
  }

  spew_qe "done.\n" if $config{title};

  prompt() if $config{interactive};

  say qq/{\n  "video": [/ if $config{json};

  my $i = 0;

  foreach (@links)
  {
    if ($_->{selected} or not $config{interactive})
    {
      ++$i;

      my $t = $_->{title} || "";
      $t =~ s/"/\\"/g;

      if ($config{json})
      {
        say "," if $i > 1;
        say "    {";
        say qq/      "title": "$t",/;
        say qq/      "url": "$_->{url}"/;
        print "    }";
      }

      elsif ($config{csv}) {say qq/"$t","$_->{url}"/;}

      else {say "$_->{url}";}
    }
  }

  if ($config{json}) {say "\n  ]\n}";}
  0;
}

sub get_title
{
  my ($a, $video, $n) = @_;

  my $r = $a->get($$video{gvi});

  unless ($r->is_success)
  {
    printf STDERR "\nerror: $$video{url}: %s\n", $r->status_line;
    return;
  }

  require CGI;
  my $q = CGI->new($r->content);

  my $title;

  if ($q->param('reason'))
  {
    printf STDERR "\nerror: %s: %s (errorcode: %d)\n",
      $$video{url}, trim($q->param("reason")),
      $q->param("errorcode");
  }
  else
  {
    require Encode;
    $title = trim(Encode::decode_utf8($q->param('title')));
    spew_qe(($n % 5 == 0) ? " " : ".");
  }
  $title;
}

sub trim
{
  my $s = shift;
  $s =~ s{^[\s]+}//;
  $s =~ s{\s+$}//;
  $s =~ s{\s\s+}/ /g;
  $s;
}

sub weed
{
  my @r = ();
  foreach (@_)
  {
    push @r, $_ if length $_ == 11;
  }
  @r;
}

sub uniq2
{    # http://is.gd/g8jQU
  my %seen = ();
  my @r    = ();
  foreach my $a (@_)
  {
    unless ($seen{$a})
    {
      push @r, $a;
      $seen{$a} = 1;
    }
  }
  @r;
}

my $done = 0;

sub prompt
{
  my %cmds = (
              'h' => \&p_help,
              'q' => sub {exit 0},
              'd' => sub {$done=1},
              'l' => \&p_show,
              'a' => \&p_select_all,
              'n' => \&p_select_none,
              'i' => \&p_invert_selection,
             );

  say STDERR qq/Enter prompt. Type "help" to get a list of commands./;
  p_show();

  my $p = "(grake) ";

  while (not $done)
  {
    print STDERR $p;

    my $ln = <STDIN>;

    next unless $ln;
    chomp $ln;

    if ($ln =~ /(\d+)/) {p_toggle($1);}

    else
    {
      next unless $ln =~ /(\w)/;
      $cmds{$1}() if defined $cmds{$1};
    }

  }
}

sub p_help
{
  say STDERR qq/Commands:
  help      .. this
  list      .. display found links (> indicates selected for download)
  all       .. select all
  none      .. select none
  invert    .. invert selection
  (number)  .. toggle caption
  dump      .. dump selected links and exit
  quit      .. quit without dumping links
Command name abbreviations are allowed, e.g. "h" instead of "help"/;
}

sub p_show
{
  my $i = 0;
  foreach (@links)
  {
    printf STDERR "%2s%02d: %s\n", $_->{selected}
      ? ">"
      : "",
      ++$i,
      $_->{title} || $_->{url};
  }
}

sub p_select_all
{
  $_->{selected} = 1 foreach @links;
  p_show();
}

sub p_select_none
{
  $_->{selected} = 0 foreach @links;
  p_show();
}

sub p_invert_selection
{
  $_->{selected} = not $_->{selected} foreach @links;
  p_show();
}

sub p_toggle
{
  my $i = (shift) - 1;
  if ($i >= 0 && exists $links[$i])
  {
    $links[$i]->{selected} = not $links[$i]->{selected};
    p_show();
  }
  else {say STDERR "error: out of range";}
}

__END__

=head1 SYNOPSIS

grake [-q] [-i] [-t] [--csv | --json] [--proxy E<lt>addrE<gt> | --no-proxy]
      [<url>...]

=head2 OPTIONS

     --help                     Print help and exit
     --version                  Print version and exit
 -q, --quiet                    Be quiet
 -i, --interactive              Run in interactive mode
 -t, --title                    Get title for video link
     --json                     Print details in json, implies -t
     --csv                      Print details in csv, implies -t
     --proxy arg (=http_proxy)  Use proxy for HTTP connections
     --no-proxy                 Disable use of HTTP proxy

=cut

# vim: set ts=2 sw=2 tw=72 expandtab:
